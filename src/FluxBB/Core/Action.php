<?php

namespace FluxBB\Core;

use FluxBB\Models\HasPermissions;
use FluxBB\Server\Exception\Forward;
use FluxBB\Server\Exception\NoPermission;
use FluxBB\Server\Exception\ValidationFailed;
use FluxBB\Server\Request;
use FluxBB\Server\Response\Data;
use FluxBB\Server\Response\Error;
use FluxBB\Server\Response\Redirect;
use Illuminate\Contracts\Support\Arrayable;
use Illuminate\Contracts\Support\MessageProvider;
use Illuminate\Contracts\Events\Dispatcher;
use Illuminate\Support\MessageBag;

abstract class Action implements MessageProvider
{
    /**
     * All data generated by this action.
     *
     * @var array
     */
    protected $data = [];

    /**
     * All errors that occurred in this action.
     *
     * @var array
     */
    protected $errors = [];

    /**
     * The event dispatcher instance.
     *
     * @var \Illuminate\Contracts\Events\Dispatcher
     */
    protected $events;

    /**
     * All event handler callbacks.
     *
     * @var array
     */
    protected $handlers = [];

    /**
     * The request that led to this action.
     *
     * @var \FluxBB\Server\Request
     */
    protected $request;

    /**
     * The request that the user should send next.
     *
     * @var \FluxBB\Server\Request
     */
    protected $nextRequest;

    /**
     * A message to be sent along with the next request.
     *
     * @var string
     */
    protected $redirectMessage = '';

    /**
     * The request to be executed in case of an error.
     *
     * @var \FluxBB\Server\Request
     */
    protected $errorRequest;


    /**
     * Make sure the given subject is authorized to execute this action.
     *
     * If authorization fails, an exception should be thrown.
     *
     * @param \FluxBB\Models\HasPermissions $subject
     * @return $this
     * @throws \FluxBB\Server\Exception\NoPermission
     */
    public function authorize(HasPermissions $subject)
    {
        return $this;
    }

    /**
     * Set the request instance.
     *
     * @param \FluxBB\Server\Request $request
     * @return $this
     */
    public function setRequest($request)
    {
        $this->request = $request;
        return $this;
    }

    /**
     * Turn a request into a response.
     *
     * @return \FluxBB\Server\Response\Response
     * @throws \Exception
     */
    public function execute()
    {
        try {
            $this->callHandlers('before');

            $this->run();

            $response = $this->makeResponse();
        } catch (ValidationFailed $e) {
            $response = $this->makeErrorResponse($e->getErrors());
        } catch (\Exception $e) {
            throw $e;
        }

        $this->callHandlers('after');

        return $response;
    }

    /**
     * Run any desired actions.
     *
     * @return void
     */
    abstract protected function run();

    /**
     * Make sure the given check passes, otherwise throw an exception.
     *
     * @param bool $check
     * @return $this
     * @throws \FluxBB\Server\Exception\NoPermission
     */
    protected function authorizedIf($check)
    {
        if (!$check) {
            throw new NoPermission;
        }

        return $this;
    }

    /**
     * Create a response based on the action's status.
     *
     * @return \FluxBB\Server\Response\Response
     * @throws \Exception
     */
    protected function makeResponse()
    {
        if ($this->hasErrors()) {
            return $this->makeErrorResponse($this->getErrors());
        } else if (isset($this->nextRequest)) {
            return new Redirect($this->nextRequest, $this->redirectMessage);
        }

        return new Data($this->data, $this->request);
    }

    /**
     * Create an error response for the given errors.
     *
     * @param \Illuminate\Support\MessageBag $errors
     * @return \FluxBB\Server\Response\Error
     * @throws \Exception
     */
    protected function makeErrorResponse(MessageBag $errors)
    {
        if (! isset($this->errorRequest)) {
            throw new \Exception('Cannot handle error, no handler declared.');
        }

        return new Error($this->errorRequest, $errors);
    }

    /**
     * Set another request that the user should send next.
     *
     * @param \FluxBB\Server\Request $next
     * @param string $message
     * @return void
     */
    protected function redirectTo(Request $next, $message = '')
    {
        $this->nextRequest = $next;
        $this->redirectMessage = $message;
    }

    /**
     * Set another request to be executed after this action.
     *
     * @param \FluxBB\Server\Request $next
     * @throws \FluxBB\Server\Exception\Forward
     */
    protected function forwardTo(Request $next)
    {
        throw new Forward($next);
    }

    /**
     * Set a request to be executed in case of an error.
     *
     * @param \FluxBB\Server\Request $next
     * @return void
     */
    protected function onErrorRedirectTo(Request $next)
    {
        $this->errorRequest = $next;
    }

    /**
     * Determine whether this action yielded any data.
     *
     * @return bool
     */
    protected function hasData()
    {
        return ! empty($this->data);
    }

    /**
     * Determine whether the action encountered any errors.
     *
     * @return bool
     */
    public function hasErrors()
    {
        return ! empty($this->errors);
    }

    /**
     * Add another error message.
     *
     * @param string $error
     * @return $this
     */
    protected function addError($error)
    {
        $this->errors[] = $error;

        return $this;
    }

    /**
     * Add the given list of error messages.
     *
     * @param \Illuminate\Contracts\Support\Arrayable $errors
     * @return $this
     */
    protected function mergeErrors(Arrayable $errors)
    {
        foreach ($errors->toArray() as $error) {
            $this->addError($error);
        }

        return $this;
    }

    /**
     * Get all error messages gathered in this action.
     *
     * @return \Illuminate\Support\MessageBag
     */
    public function getErrors()
    {
        return new MessageBag($this->errors);
    }

    /**
     * Set the event dispatcher instance.
     *
     * @param \Illuminate\Contracts\Events\Dispatcher $events
     * @return void
     */
    public function setEvents(Dispatcher $events)
    {
        $this->events = $events;
    }

    /**
     * Raise the given event.
     *
     * @param object $event
     * @return void
     */
    protected function raise($event)
    {
        $qualified = get_class($event);
        $name = str_replace('\\', '.', $qualified);

        $this->events->fire($name, [$event]);
    }

    /**
     * Register a callback to be executed before running the action.
     *
     * @param callable $callback
     * @return $this
     */
    public function before(callable $callback)
    {
        $this->registerHandler('before', $callback);
        return $this;
    }

    /**
     * Register a callback to be executed after running the action.
     *
     * @param callable $callback
     * @return $this
     */
    public function after(callable $callback)
    {
        $this->registerHandler('after', $callback);
        return $this;
    }

    /**
     * Register a callback to be executed if the action is successfully executed.
     *
     * @param callable $callback
     * @return $this
     */
    public function onSuccess(callable $callback)
    {
        $this->registerHandler('success', $callback);
        return $this;
    }

    /**
     * Register a callback to be executed in case of an error.
     *
     * @param callable $callback
     * @return $this
     */
    public function onError(callable $callback)
    {
        $this->registerHandler('error', $callback);
        return $this;
    }

    /**
     * Register a callback for a certain type of event.
     *
     * @param string $type
     * @param callable $callback
     * @return void
     */
    protected function registerHandler($type, callable $callback)
    {
        $this->handlers[$type][] = $callback;
    }

    /**
     * Execute all handlers of the given type.
     *
     * @param string $type
     * @return void
     */
    protected function callHandlers($type)
    {
        if (isset($this->handlers[$type])) {
            $arguments = func_get_args();
            $arguments[0] = $this;

            foreach ($this->handlers[$type] as $handler) {
                call_user_func_array($handler, $arguments);
            }
        }
    }

    /**
     * Get the messages for the instance.
     *
     * @return \Illuminate\Support\MessageBag
     */
    public function getMessageBag()
    {
        return $this->getErrors();
    }
}
